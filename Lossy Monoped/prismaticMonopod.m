classdef prismaticMonopod
    %prismaticMonopod This class encapsulates robot information and
    %dynamics functions
    %   Autogenerated dynamics functions are included inside of this class. 
    
    %   TODO: It would be better to have a seperate autogenerated dynamics
    %   directory. This class would then call the appropriate functions 
    %   inside that folder and regerate them when necessary
    
    properties
        %MODEL PARAMETERS
        grav = 9.81
        %Main Body
        m_body = 10;
        I_body = 0.1;  % Confirmed Realistic
        %Hip Joint
        b_hip = 1;
        %Thigh
        m_thigh = 0.2;
        r_thigh = 0.2;
        I_thigh = 0.01; % Confirmed Realistic
        %Leg Length Rotor
        b_rot = 1;
        m_rot = 4;  %Effective reflective interia on linear leg length
        %Leg Spring
        k_leg = 1000;
        b_leg = 10;
        %Toe
        m_toe = 0.3;
        
        %MODEL STATE INFO
        %Time
        t = 0;
        %Recorded State
        dynamic_state_arr = 0;
        %World Frame state data
        q = [0,0.85,0,0,0.7,0.7]; %Some basic initial state data
        qdot = zeros(1,6);
        %Torque Actuation Data
        u = [0,0];
        ctrlParams;
        
        %SIMULATION SETTINGS
        %Controller Update time step
        T_ctrl = 1/1000 %Run at 1 KHz
        %physics timestep
        T_ratio = 3 %Number of simulation steps per controller step
    end
    
    methods
        function f = footForce(robot,q,qdot)
        %FOOTFORCE This function returns the sum of non-contact forces on the foot in the
        %direction of the leg. It is used to determine liftoff conditions.
        %Towards the body from the foot is positive
            if length(q) == 6 
                f = 0; %In flight
            else
                f =   robot.k_leg*(sqrt(q(1)^2 + q(2)^2) - q(4))... %Spring Force
                    - robot.m_toe*robot.grav* q(2)/sqrt(q(1)^2 + q(2)^2)... %Gravitational Force
                    + robot.b_leg*((q(1)*qdot(1) + q(2)*qdot(2))/(sqrt(qdot(1)^2 + qdot(2)^2) - qdot(4))); %Leg Damping                 
            end
        end
        
        function f = footForceDot(robot,q,qdot)
        %FOOTFORCE This function returns the sum of non-contact forces on the foot in the
        %direction of the leg. It is used to determine liftoff conditions.
        %Towards the body from the foot is positive
            if length(q) == 6 
                f = 0; %In flight
            else
                f =   robot.k_leg*(sqrt(q(1)^2 + q(2)^2) - q(4))... %Spring Force
                    - robot.m_toe*robot.grav* q(2)/sqrt(q(1)^2 + q(2)^2); %Gravitational Force
%                     + robot.b_leg*(sqrt(qdot(1)^2 + qdot(2)^2) - qdot(4))... %Leg Damping                 
            end
        end
        
        function robot = fillSimData(robot,t,y_in,u,dynamicState)
        %fillSimData This function copies the state data (y) into the object
        %members. What the state variables represent is different depending on the
        %dynamic state (stance, flight).


            robot.dynamic_state_arr = [robot.dynamic_state_arr;dynamicState*ones(size(t))];            
            robot.u = [robot.u;u'];
            
            switch dynamicState
                case 0 %Flight phase
                    robot.t =       [robot.t;      t];
                    robot.q =       [robot.q;      y_in(:,1:6)]; 
                    robot.qdot =    [robot.qdot;   y_in(:,7:12)]; 

                case 1 %Stance            
                    %States that are driven when the foot is on the ground
                    %Leg Angle: toe is at (0,0)
                    ydot = y_in(:,5:8);
                    y = y_in(:,1:4);
                    alpha = atan2(-y(:,1),y(:,2));
                    alphadot = ( y(:,1).*ydot(:,2)./(y(:,2).^2) - ydot(:,1)./y(:,2) ) ./ ( 1 + (y(:,1)./y(:,2)).^2 ); 
                    %Leg Length: toe is at (0,0)
                    L = sqrt(y(:,1).^2 + y(:,2).^2);
                    Ldot = ( y(:,1).*ydot(:,1) + y(:,2).*ydot(:,2) ) ./ sqrt(y(:,1).^2 + y(:,2).^2);

                    %Foot Location needed to move from a coordinate system relative
                    %to the foot to a global coordinate system
                    xFootLocation = robot.q(end,1) + robot.q(end,6)*sin(robot.q(end,4));
                    yFootLocation = robot.q(end,2) - robot.q(end,6)*cos(robot.q(end,4));

                    robot.t =       [robot.t;       t];            
                    robot.q =       [robot.q;       (y(:,1) + xFootLocation),y(:,2) + yFootLocation, y(:,3),alpha,y(:,4),L]; 
                    robot.qdot =    [robot.qdot;    ydot(:,1:3),alphadot,ydot(:,4),Ldot]; 
            end %switch
        end %Function fillSimData
        
        function f = massMatrixFlight(obj,in1)
        %massMatrixFlight Autogenerated Mass Matrix
            q4 = in1(4,:);
            q6 = in1(6,:);
            t2 = cos(q4);
            t3 = obj.m_body+obj.m_toe+obj.m_thigh;
            t4 = sin(q4);
            t5 = obj.m_toe.*q6.*t2;
            t6 = obj.m_thigh.*obj.r_thigh.*t2;
            t7 = t5+t6;
            t8 = obj.m_toe.*q6.*t4;
            t9 = obj.m_thigh.*obj.r_thigh.*t4;
            t10 = t8+t9;
            t11 = obj.m_toe.*t4;
            f = reshape([t3,0.0,0.0,t7,0.0,t11,0.0,t3,0.0,t10,0.0,-obj.m_toe.*t2,0.0,0.0,obj.I_body,0.0,0.0,0.0,t7,t10,0.0,obj.I_thigh+obj.m_toe.*q6.^2+obj.m_thigh.*obj.r_thigh.^2,0.0,0.0,0.0,0.0,0.0,0.0,obj.m_rot,0.0,t11,-obj.m_toe.*t2,0.0,0.0,0.0,obj.m_toe],[6,6]);
        end
        
        function f = dynamicsFlight(obj,in1,in2)
        %DYNAMICSFLIGHT Autogenerated coordinate forces from lagrangian dynamics
            q4 = in1(4,:);
            q5 = in1(5,:);
            q6 = in1(6,:);
            qdot4 = in2(4,:);
            qdot6 = in2(6,:);
            t2 = sin(q4);
            t3 = cos(q4);
            t4 = qdot4.^2;
            f = [qdot4.*(obj.m_toe.*(qdot6.*t3.*2.0-q6.*qdot4.*t2.*2.0).*(1.0./2.0)-obj.m_thigh.*qdot4.*obj.r_thigh.*t2)+obj.m_toe.*qdot4.*qdot6.*t3;obj.grav.*obj.m_body+obj.grav.*obj.m_toe+obj.grav.*obj.m_thigh+obj.m_toe.*qdot4.*qdot6.*t2.*2.0+obj.m_toe.*q6.*t3.*t4+obj.m_thigh.*obj.r_thigh.*t3.*t4;0.0;obj.grav.*obj.m_toe.*q6.*t2+obj.grav.*obj.m_thigh.*obj.r_thigh.*t2+obj.m_toe.*q6.*qdot4.*qdot6.*2.0;obj.k_leg.*(q5.*2.0-q6.*2.0).*(1.0./2.0);-obj.k_leg.*q5+obj.k_leg.*q6-obj.grav.*obj.m_toe.*t3-obj.m_toe.*q6.*t4];
        end
        
        function B = controlFlight(obj,q)
        %CONTROLFLIGHT returns B(q) Matrix to map actuation forces to generalized
        %coordinates
            B = [ -sin(q(4)),  0; ...
                    cos(q(4)),	0; ...
                    0,          -1;...
                    0,          1;...
                    1,          0;...
                    0,          0;];
        end
        
        function f_d = dampingFlight(o,q,qdot)
            f_d = [ -o.b_rot * qdot(5) * sin(q(4)); ... %Rotor damping
                    -o.b_rot * qdot(5) * cos(q(4)); ... %Rotor damping
                    -o.b_hip * (qdot(3) - qdot(4)); ... %Hip Joint Damping
                    -o.b_hip * (qdot(4) - qdot(3)); ... %Hip Joint Damping
                    -o.b_rot * qdot(5) * sin(q(4)) - o.b_leg * (qdot(5) - qdot(6)); ... %Rotor Damping and Leg Spring Damping
                    - o.b_leg * (qdot(6) - qdot(5)); ]; %Leg spring damping
        end
        
        function f = massMatrixStance(obj,in1)
        %massMatrixStance Autogenerated Mass Matrix
            q1 = in1(1,:);
            q2 = in1(2,:);
            t2 = q2.^2;
            t3 = q1.^2;
            t4 = t2+t3;
            t5 = t3.^2;
            t6 = t4.^(5.0./2.0);
            t7 = t2.^2;
            t8 = 1.0./t4.^(1.1e1./2.0);
            t9 = 1.0./t4.^2;
            f = reshape([t8.*(obj.I_thigh.*t6.*t7+obj.I_thigh.*t2.*t3.*t6+obj.m_body.*t2.*t5.*t6.*3.0+obj.m_body.*t3.*t5.*t6+obj.m_body.*t2.*t6.*t7+obj.m_body.*t3.*t6.*t7.*3.0),-obj.I_thigh.*q1.*q2.*t9,0.0,0.0,-t8.*(obj.I_thigh.*q1.*q2.*t2.*t6+obj.I_thigh.*q1.*q2.*t3.*t6),obj.m_body+obj.I_thigh.*t3.*t9,0.0,0.0,0.0,0.0,obj.I_body,0.0,0.0,0.0,0.0,obj.m_rot],[4,4]);
        end
        
        function f = dynamicsStance(obj,in1,in2)
        %DYNAMICSSTANCE Autogenerated coordinate forces from lagrangian dynamics
            q1 = in1(1,:);
            q2 = in1(2,:);
            q4 = in1(4,:);
            qdot1 = in2(1,:);
            qdot2 = in2(2,:);
            t2 = q1.^2;
            t3 = t2.^2;
            t4 = t3.^2;
            t5 = q2.^2;
            t6 = t2+t5;
            t7 = t5.^2;
            t8 = t6.^(5.0./2.0);
            t9 = t7.^2;
            t10 = 1.0./sqrt(t6);
            t11 = qdot1.^2;
            t12 = qdot2.^2;
            t13 = 1.0./t6.^2;
            t14 = 1.0./q2;
            t15 = 1.0./t6.^3;
            t16 = 1.0./t6.^(3.0./2.0);
            t17 = 1.0./t6.^(5.0./2.0);
            f = [1.0./t6.^(1.1e1./2.0).*(obj.I_thigh.*q1.*t5.*t8.*t11.*-2.0+obj.I_thigh.*q1.*t5.*t8.*t12.*2.0-obj.k_leg.*q1.*q4.*t2.*t4-obj.k_leg.*q1.*q4.*t4.*t5.*5.0-obj.k_leg.*q1.*q4.*t2.*t9.*5.0-obj.k_leg.*q1.*q4.*t5.*t9+obj.k_leg.*q1.*t2.*t3.*t8+obj.k_leg.*q1.*t3.*t5.*t8.*3.0+obj.k_leg.*q1.*t2.*t7.*t8.*3.0+obj.k_leg.*q1.*t5.*t7.*t8-obj.k_leg.*q1.*q4.*t2.*t3.*t7.*1.0e1-obj.k_leg.*q1.*q4.*t3.*t5.*t7.*1.0e1+obj.I_thigh.*q2.*qdot1.*qdot2.*t2.*t8.*2.0-obj.I_thigh.*q2.*qdot1.*qdot2.*t5.*t8.*2.0+obj.grav.*obj.m_thigh.*q1.*q2.*obj.r_thigh.*t4+obj.grav.*obj.m_thigh.*q1.*q2.*obj.r_thigh.*t9+obj.grav.*obj.m_thigh.*q1.*q2.*obj.r_thigh.*t3.*t7.*6.0+obj.grav.*obj.m_thigh.*q1.*q2.*obj.r_thigh.*t2.*t3.*t5.*4.0+obj.grav.*obj.m_thigh.*q1.*q2.*obj.r_thigh.*t2.*t5.*t7.*4.0);obj.grav.*obj.m_body+obj.grav.*obj.m_thigh+obj.k_leg.*q2-obj.grav.*obj.m_thigh.*obj.r_thigh.*t10-obj.k_leg.*q2.*q4.*t10+obj.I_thigh.*q1.*qdot1.*qdot2.*t13.*2.0+obj.I_thigh.*q2.*t2.*t11.*t15.*2.0-obj.I_thigh.*t2.*t12.*t13.*t14.*2.0+obj.I_thigh.*t3.*t12.*t14.*t15.*2.0+obj.grav.*obj.m_thigh.*obj.r_thigh.*t5.*t16-obj.m_thigh.*q1.*qdot1.*obj.r_thigh.*t16.*(3.0./2.0)+obj.m_thigh.*q2.*qdot1.*obj.r_thigh.*t16.*(3.0./2.0)+obj.m_thigh.*q1.*qdot1.*obj.r_thigh.*t2.*t17.*(3.0./2.0)-obj.m_thigh.*q2.*qdot1.*obj.r_thigh.*t2.*t17.*(3.0./2.0)+obj.m_thigh.*q1.*qdot1.*obj.r_thigh.*t5.*t17.*(3.0./2.0)-obj.m_thigh.*q2.*qdot1.*obj.r_thigh.*t5.*t17.*(3.0./2.0)-obj.I_thigh.*q1.*qdot1.*qdot2.*t2.*t15.*4.0;0.0;obj.k_leg.*(q4.*2.0-sqrt(t6).*2.0).*(1.0./2.0)];
        end
        
        function B = controlStance(obj,q)
        %CONTROLSTANCE returns B(q) Matrix to map actuation forces to generalized
        %coordinates
            B = [ (q(1)/sqrt(q(1)^2 + q(2)^2)),  0; ...
                    (q(2)/sqrt(q(1)^2 + q(2)^2)),	0; ...
                    0,          -1;...
                    1,          0;];
        end
        
        function f_d = dampingStance(o,q,qdot)
            %Useful States that are driven when the foot is on the ground
            %Leg Angle: toe is at (0,0)
            alphadot = ( q(1)*qdot(2)/(q(2)^2) - qdot(1)/q(2) ) / ( 1 + (q(1)/q(2))^2 ); 
            %Leg Length: toe is at (0,0)
            L = sqrt(q(1)^2 + q(2)^2);
            
            f_d = [ -o.b_rot * qdot(4) * (-q(1)/sqrt(q(1)^2 + q(2)^2)); ... %Rotor damping
                    -o.b_rot * qdot(4) * (q(2)/sqrt(q(1)^2 + q(2)^2)); ... %Rotor damping
                    -o.b_hip * (qdot(3) - alphadot); ... %Hip Joint Damping
                    -o.b_rot * qdot(4) * (-q(1)/sqrt(q(1)^2 + q(2)^2)) - o.b_leg * (qdot(4) - L);]; %Rotor Damping and Leg Spring Damping                 
        end
        
        
    end %METHODS
    
end %CLASS



